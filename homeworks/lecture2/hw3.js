// What would be the output of following code?
// Explain your answer.

console.log(0.1 + 0.2);
//0.30000000000000004
//这是由于浮点数计算精度问题导致的微小误差。

console.log(0.1 + 0.2 == 0.3);
//false
//由于浮点数计算精度问题，0.1 + 0.2并不等于0.3。

console.log(1 + "2" + "2");
//122
//数字1和字符串"2"拼接后再和字符串"2"拼接。

console.log(1 + +"2" + "2");
//32
//+"2"将字符串"2"转换为数字2，然后进行加法运算。

console.log(1 + -"1" + "2");
//02
//-"1"将字符串"1"转换为数字-1，然后进行加法运算。

console.log(+"1" + "1" + "2");
//112
//+"1"将字符串"1"转换为数字1，然后进行加法运算。

console.log("A" - "B" + "2");
//NaN2
//无法将字符转换为数字，因此得到NaN。

console.log("A" - "B" + 2);
//NaN
//同样无法将字符转换为数字，因此得到NaN。

console.log("0 || 1 = " + (0 || 1));
//0 || 1 = 1
//逻辑或运算符||返回第一个为真的值。

console.log("1 || 2 = " + (1 || 2));
//1 || 2 = 1
//同样逻辑或运算符||返回第一个为真的值。

console.log("0 && 1 = " + (0 && 1));
//0 && 1 = 0
//逻辑与运算符&&返回第一个为假的值,或者最后一个值。

console.log("1 && 2 = " + (1 && 2));
//1 && 2 = 2
//逻辑与运算符&&返回第一个为假的值，或者最后一个值。

console.log(false == "0");
//true
//因为双等号会进行类型转换。

console.log(false === "0");
//false
//因为全等号不会进行类型转换。
